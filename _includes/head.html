<head>
<meta charset="utf-8">
{% include normalize_url.html %}
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=5">
<link rel="apple-touch-icon" sizes="180x180" href="/assets/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/assets/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/assets/favicon-16x16.png">
<link rel="manifest" href="/assets/site.webmanifest">
<link rel="mask-icon" href="/assets/safari-pinned-tab.svg" color="#5bbad5">
<link rel="shortcut icon" href="/assets/favicon.ico">
<meta name="msapplication-TileColor" content="#da532c">
<meta name="msapplication-config" content="/assets/browserconfig.xml">
<meta name="theme-color" content="#ffffff">

{% include lazy_load_css.html href="/assets/css/vendor/iosevka.min.css" %}

{% if page.content contains '"ytdefer"' or page.content contains 'include youtube_player.html' %}
<script src="/assets/js/vendor/ytdefer.min.js" defer></script>
{% endif %}


<script src="/assets/js/vendor/bootstrap.bundle.min.js" defer></script>
{% include lazy_load_css.html href="/assets/css/vendor/bootstrap.min.css" %}
<script>
document.addEventListener("DOMContentLoaded", () => {
 const tooltipTriggers = document.querySelectorAll('[data-bs-toggle="tooltip"]')
 const tooltips = [...tooltipTriggers].map(i => {
  i.removeAttribute('title');
  return new bootstrap.Tooltip(i);
 });
});
</script>


<!-- {% if site.theme_settings.external_google_fonts %}
{% assign google_fonts_url="https://fonts.googleapis.com/css?family=" | append: site.theme_settings.google_fonts %}
{% else %}
{% assign google_fonts_url="/assets/css/vendor/google-fonts.min.css" %}
{% endif %}
{% include lazy_load_css.html href=google_fonts_url %} -->

{% if site.theme_settings.typed %}
<script src="/assets/js/vendor/typed.min.js" defer></script>
{% endif %}


{% if page.content contains '$' %}

{% if site.theme_settings.katex %}
<link rel="stylesheet" type="text/css" href="/assets/css/vendor/katex.min.css">
<script src="/assets/js/vendor/katex.min.js" defer></script>
{% endif %}

<script type="text/x-mathjax-config">
MathJax.Hub.Config({
 tex2jax: {
  skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'],
  inlineMath: [['$','$']]
 }
});
</script>
<script src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML' async></script>
{% endif %}


<link rel="stylesheet" href="/assets/css/vendor/vidstack-player/video.css" />
<link rel="stylesheet" href="/assets/css/vendor/vidstack-player/theme.css" />
<script type="importmap">
{
 "imports": {
  "p2p-media-loader-core": "/assets/js/vendor/p2p-media-loader-core.es.min.js",
  "p2p-media-loader-hlsjs": "/assets/js/vendor/p2p-media-loader-hlsjs.es.min.js"
 }
}
</script>

<script type="module">
import '/assets/js/vendor/hls.min.js';
import { HlsJsP2PEngine } from 'p2p-media-loader-hlsjs';
import '/assets/js/vendor/vidstack-player/vidstack.js';

const pageLog = text => {
 if (window.location.pathname !== '/ru/video-test/') return;
 const p = document.createElement('p');
 p.textContent = text;
 p.style.color = 'green'
 p.style.fontWeight = '800';
 document.body.appendChild(p);
};

const codecSupported = codec =>
 ("ManagedMediaSource" in window && ManagedMediaSource.isTypeSupported(codec)) || ("MediaSource" in window && MediaSource.isTypeSupported(codec));

document.addEventListener("DOMContentLoaded", () => {
 const HlsWithP2P = HlsJsP2PEngine.injectMixin(window.Hls);

 const loadStoryboard = (player, videoLayout) => {
  const duration = player.duration;
  const maxSize = {{ site.theme_settings.p2p_player.storyboard.max_size }};
  const intervalSec = {{ site.theme_settings.p2p_player.storyboard.interval_sec }};
  const tileWidth = {{ site.theme_settings.p2p_player.storyboard.tile_width }};
  const tileHeight = Math.floor(tileWidth * (9 / 16));
  const tiles = [];

  const maxTilesHorizontal = Math.floor(maxSize / tileWidth);
  const maxTilesVertical = Math.floor(maxSize / tileHeight);

  const frameArea = tileWidth * tileHeight;
  const maxFrames = Math.floor(Math.pow(maxSize, 2) / frameArea);

  const frames = Math.min(Math.ceil(duration / intervalSec), maxFrames);
  const size = Math.sqrt(frames * frameArea);
  const tilesHorizontal = Math.min(Math.ceil(size / tileWidth), maxTilesHorizontal);
  const tilesVertical = Math.min(Math.ceil(frames / tilesHorizontal), maxTilesVertical);

  let frame = 1;
  let startTime = 0;
  for (let y = 0; y < tilesVertical; y++) {
   for (let x = 0; x < tilesHorizontal; x++) {
    tiles.push({ startTime, x: x * tileWidth, y: y * tileHeight });
    startTime += intervalSec;
    frame++;
    if (frame >= frames) break; // last frame might be invalid, ignoring it
   }
  }

  const url = URL.parse(player.getAttribute('src') + '/../storyboard.webp').href;
  videoLayout.thumbnails = { url, tileWidth, tileHeight, tiles };
 };

 const parseTime = time => {
  let hours = 0;
  let minutes = 0;
  let seconds = 0;
  if (time[1] && time[2] && time[3]) {
   hours = parseInt(time[1]);
   minutes = parseInt(time[2]);
   seconds = parseInt(time[3]);
  } else if (time[1] && time[2]) {
   minutes = parseInt(time[1]);
   seconds = parseInt(time[2]);
  }
  return hours * 60*60 + minutes * 60 + seconds;
 };

 const loadChapters = player => {
  const duration = player.duration;
  const element = document.querySelector(`.p2p-player-chapters[data-stream-url="${player.getAttribute('src')}"]`);
  if (!element) return;

  const lines = element
   .innerText
   .split('\n')
   .map(i => i.trim())
   .filter(i => i.length > 0);
  const cues = [];

  for (const [index, line] of lines.entries()) {
   try {
    const timeRegex = /^(\d{2})(?::(\d{2})):?(\d{2})?/;
    const time = line.match(timeRegex);
    if (!time) continue;

    const startTime = parseTime(time);
    if (startTime >= duration) break;

    const text = line.substring(time[0].length).trim();
    let endTime = duration;
    if (index + 1 < lines.length) {
     const nextTime = lines[index + 1].match(timeRegex);
     if (nextTime) {
      endTime = parseTime(nextTime);
      if (endTime > duration) break;
     }
    }
    cues.push({ startTime, endTime, text });
   } catch (err) {
    console.error(err);
   }
  }

  player.textTracks.add({
   type: 'json',
   kind: 'chapters',
   language: '{{ page.lang }}',
   content: { cues },
   default: true,
  });
 };

 const loadMetadata = (player, videoLayout) => {
   loadStoryboard(player, videoLayout);
   loadChapters(player);
 };

 const initializePlayer = player => {
  const videoLayout = player.querySelector('media-video-layout');
  const poster = player.querySelector("media-poster");

  //videoLayout.smallWhen = ({ width, height }) => width < 611.93 || height < 344; // FIXME
  videoLayout.playbackRates = { min: 0.5, max: 2.5, step: 0.05 };
  //videoLayout.hideQualityBitrate = true;

  if (player.duration > 0) {
   loadMetadata(player, videoLayout);
  } else {
   player.addEventListener('loaded-metadata', event => loadMetadata(player, videoLayout));
  }

  player.addEventListener('play-fail', event => {
   if (event.isOriginTrusted) {
    player.play();
   }
  });

  for (const i of ['provider-change', 'seeking']) {
   player.addEventListener(i, event => poster.setAttribute('data-visible', true));
  }

  const hidePosterAndPlayButton = () => {
   const style = document.createElement('style');
   style.textContent = `
    .vds-video-layout[data-sm, thumbnails="${videoLayout.getAttribute('thumbnails')}"] {
     .vds-play-button {
      --media-button-size: 50px;
      --media-button-border: none;
      --video-sm-play-button-bg: transparent;
     }
     .vds-play-button:hover {
      --media-button-border: none;
      --video-sm-play-button-bg: transparent;
     }
    }`;
   player.appendChild(style);
   poster.style.visibility = 'hidden';
  };

  player.addEventListener('play', event => hidePosterAndPlayButton());

  player.addEventListener('seeking', event => {
   if (event.originEvent?.type === 'pointerdown') {
    hidePosterAndPlayButton();
   }
  });

  // 'time-change'
  /*player.addEventListener('time-update', event => {
   console.log('time', event.detail);
  });*/

  player.addEventListener('stalled', event => {
   pageLog('stalled');
  });

  player.addEventListener("provider-change", event => {
   const provider = event.detail;
   console.log('provider-change', provider);
   if (provider?.type === 'hls') {
    provider.library = HlsWithP2P;
    provider.config = {
     p2p: {
      core: {
       // swarmId: player.getAttribute('src'),
       // isP2PDisabled: false,
       // simultaneousHttpDownloads: 2,
       // simultaneousP2PDownloads: 3,
       // highDemandTimeWindow: 15,
       // httpDownloadTimeWindow: 3e3,
       // p2pDownloadTimeWindow: 6e3,
       // webRtcMaxMessageSize: 64 * 1024 - 1,
       // p2pNotReceivingBytesTimeoutMs: 2e3,
       // p2pInactiveLoaderDestroyTimeoutMs: 30 * 1e3,
       // httpNotReceivingBytesTimeoutMs: 3e3,
       // httpErrorRetries: 3,
       // p2pErrorRetries: 3,
       p2pErrorRetries: Infinity,
       announceTrackers: {{ site.theme_settings.p2p_player.trackers | jsonify }},
       rtcConfig: { iceServers: {{ site.theme_settings.p2p_player.ice_servers | jsonify }}.map(urls => { return { urls }; }) },
      },
      onHlsJsCreated: (hls) => {
       hls.p2pEngine.addEventListener('onPeerConnect', (params) => {
        pageLog('Peer connected:' + params.peerId);
       });
       hls.p2pEngine.addEventListener('onPeerError', (params) => {
        pageLog('Peer error:' + params.peerId);
       });
       hls.p2pEngine.addEventListener('onPeerClose', (params) => {
        pageLog('Peer disconnected:' + params.peerId);
       });
       hls.p2pEngine.addEventListener('onChunkDownloaded', (bytesLength, downloadSource, peerId) => {
        if (peerId) {
         pageLog('Peer download:' + bytesLength + ' ' + peerId + ' ' + downloadSource);
        }
       });
       hls.p2pEngine.addEventListener('onChunkUploaded', (bytesLength, peerId) => {
        pageLog('Peer UPdownload:' + bytesLength + ' ' + peerId);
       });
       hls.p2pEngine.addEventListener('onSegmentLoaded', (params) => {
        if (params.peerId) {
          pageLog('P2P Segment loaded:' + params.bytesLength);
        }
       });
       hls.p2pEngine.addEventListener('onSegmentError', (params) => {
        pageLog('ERROR loading segment:' + JSON.stringify(params));
       });

       hls.on(Hls.Events.MANIFEST_PARSED, function (event, data) {
        console.log(data);
        pageLog('manifest loaded, found ' + data.levels.length + ' quality level');
       });
       hls.on(Hls.Events.BUFFER_CREATED, function (event, data) {
        pageLog('codec: ' + data.tracks.audiovideo.codec);
       });
       // TODO: connectedPeerCount

       pageLog(codecSupported(`video/mp4;codecs="avc1.64002a,mp4a.40.2"`) + ' ' + codecSupported(`video/webm;codecs="av01.0.09M.08.0.110.01.01.01.0,opus"`));
      },
     },
    };
   }
  });
 };

 if (Hls?.isSupported()) {
  pageLog('hls is supported');
  document.querySelectorAll('media-player').forEach(initializePlayer);
 } else {
  pageLog('hls is unsupported!');
 }
});
</script>


{% if site.theme_settings.google_analytics %}
<script src="https://www.googletagmanager.com/gtag/js?id={{ site.theme_settings.google_analytics }}" async></script>
<script>
window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', '{{ site.theme_settings.google_analytics }}');
</script>
{% endif %}

{% if site.theme_settings.zapthreads %}
<script type="text/javascript" src="/assets/js/vendor/zapthreads.iife.js"></script>
{% endif %}

<meta name="twitter:site" content="@{{ site.theme_settings.twitter }}">

{% if page.summary %}
<meta name="twitter:description" content="{{ page.summary }}">
{% else %}
<meta name="twitter:description" content="{% if page.lang == 'en' %}{{ site.description | xml_escape }}{% else %}{{ page.str.description | xml_escape }}{% endif %}">
{% endif %}

{% if page.thumbnail %}
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="{{ site.url }}/{{ page.thumbnail }}">
{% else %}
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="{{ site.title_image }}">
{% endif %}

{% if page.lang != 'en' and page.layout == 'home' %}
<title>{{ site.title }} | {{ page.str.description | xml_escape }}</title>
{% seo title=false %}
{% else %}
{% seo %}
{% endif %}

<link rel="alternate" type="application/atom+xml" title="{{ site.title }}" href="{{ site.url }}/{% if page.lang != 'en' %}{{ page.lang }}/{% endif %}{{ site.baseurl }}feed.xml"/>

<script type="module" src="/assets/js/main.min.js" defer></script>
{% include lazy_load_css.html href="/assets/css/main.css" %}
</head>
