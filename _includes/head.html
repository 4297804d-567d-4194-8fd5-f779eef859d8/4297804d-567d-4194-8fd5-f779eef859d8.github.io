<head>
<meta charset="utf-8">
{% include normalize_url.html %}
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=5">
<link rel="apple-touch-icon" sizes="180x180" href="/assets/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/assets/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/assets/favicon-16x16.png">
<link rel="manifest" href="/assets/site.webmanifest">
<link rel="mask-icon" href="/assets/safari-pinned-tab.svg" color="#5bbad5">
<link rel="shortcut icon" href="/assets/favicon.ico">
<meta name="msapplication-TileColor" content="#da532c">
<meta name="msapplication-config" content="/assets/browserconfig.xml">
<meta name="theme-color" content="#ffffff">

{% include lazy_load_css.html href="/assets/css/vendor/iosevka.min.css" %}

{% if page.content contains '"ytdefer"' or page.content contains 'include youtube_player.html' %}
<script src="/assets/js/vendor/ytdefer.min.js" defer></script>
{% endif %}


<script src="/assets/js/vendor/bootstrap.bundle.min.js" defer></script>
{% include lazy_load_css.html href="/assets/css/vendor/bootstrap.min.css" %}
<script>
document.addEventListener("DOMContentLoaded", () => {
 const tooltipTriggers = document.querySelectorAll('[data-bs-toggle="tooltip"]')
 const tooltips = [...tooltipTriggers].map(i => {
  i.removeAttribute('title');
  return new bootstrap.Tooltip(i);
 });
});
</script>


<!-- {% if site.theme_settings.external_google_fonts %}
{% assign google_fonts_url="https://fonts.googleapis.com/css?family=" | append: site.theme_settings.google_fonts %}
{% else %}
{% assign google_fonts_url="/assets/css/vendor/google-fonts.min.css" %}
{% endif %}
{% include lazy_load_css.html href=google_fonts_url %} -->

{% if site.theme_settings.typed %}
<script src="/assets/js/vendor/typed.min.js" defer></script>
{% endif %}


{% if page.content contains '$' %}

{% if site.theme_settings.katex %}
<link rel="stylesheet" type="text/css" href="/assets/css/vendor/katex.min.css">
<script src="/assets/js/vendor/katex.min.js" defer></script>
{% endif %}

<script type="text/x-mathjax-config">
MathJax.Hub.Config({
 tex2jax: {
  skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'],
  inlineMath: [['$','$']]
 }
});
</script>
<script src='https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js?config=TeX-MML-AM_CHTML' async></script>
{% endif %}


<link rel="stylesheet" href="/assets/css/vendor/vidstack-player/video.css" />
<link rel="stylesheet" href="/assets/css/vendor/vidstack-player/theme.css" />
<script type="importmap">
{
 "imports": {
  "p2p-media-loader-core": "/assets/js/vendor/p2p-media-loader-core.es.min.js",
  "p2p-media-loader-hlsjs": "/assets/js/vendor/p2p-media-loader-hlsjs.es.min.js"
 }
}
</script>

<script type="module">
import '/assets/js/vendor/hls.min.js';
import { HlsJsP2PEngine } from 'p2p-media-loader-hlsjs';
import '/assets/js/vendor/vidstack-player/vidstack.js';

const pageLog = text => {
 if (window.location.pathname === '/ru/video-test/') {
  const p = document.createElement('p');
  p.textContent = text;
  p.style.color = 'green'
  p.style.fontWeight = '800';
  document.body.appendChild(p);
 } else {
  console.log(text);
 }
};

const codecSupported = codec =>
 ("ManagedMediaSource" in window && ManagedMediaSource.isTypeSupported(codec)) || ("MediaSource" in window && MediaSource.isTypeSupported(codec));

document.addEventListener("DOMContentLoaded", () => {
 const HlsWithP2P = HlsJsP2PEngine.injectMixin(window.Hls);

 const loadStoryboard = (player, videoLayout) => {
  const duration = player.duration;
  const maxSize = {{ site.theme_settings.p2p_player.storyboard.max_size }};
  const intervalSec = {{ site.theme_settings.p2p_player.storyboard.interval_sec }};
  const tileWidth = {{ site.theme_settings.p2p_player.storyboard.tile_width }};
  const tileHeight = Math.floor(tileWidth * (9 / 16));

  const maxTilesHorizontal = Math.floor(maxSize / tileWidth);
  const maxTilesVertical = Math.floor(maxSize / tileHeight);

  const frameArea = tileWidth * tileHeight;
  const maxFrames = Math.floor(Math.pow(maxSize, 2) / frameArea);

  const frames = Math.min(Math.floor(duration / intervalSec), maxFrames);
  const size = Math.sqrt(frames * frameArea);
  const tilesHorizontal = Math.min(Math.ceil(size / tileWidth), maxTilesHorizontal);
  const tilesVertical = Math.min(Math.ceil(frames / tilesHorizontal), maxTilesVertical);

  const tiles = [];
  let frame = 0;
  for (let y = 0; y < tilesVertical; y++) {
   for (let x = 0; x < tilesHorizontal && frame < frames; x++) {
    const startTime = frame * intervalSec;
    tiles.push({ startTime, x: x * tileWidth, y: y * tileHeight });
    frame++;
   }
  }

  const url = new URL(player.getAttribute('src') + '/../storyboard.webp').href;
  videoLayout.thumbnails = { url, tileWidth, tileHeight, tiles };
 };

 const parseTime = time => {
  let hours = 0;
  let minutes = 0;
  let seconds = 0;
  if (time[1] && time[2] && time[3]) {
   hours = parseInt(time[1]);
   minutes = parseInt(time[2]);
   seconds = parseInt(time[3]);
  } else if (time[1] && time[2]) {
   minutes = parseInt(time[1]);
   seconds = parseInt(time[2]);
  }
  return hours * 60*60 + minutes * 60 + seconds;
 };

 const playerQueryParameters = (playerIndex, startTime) => {
  const time = parseFloat(startTime.toFixed(3));
  const ts = [...new Array(playerIndex).fill('t='), `t=${time}`];
  return '?' + ts.join('&');
 };

 const loadChapters = (player, playerIndex) => {
  const duration = player.duration;
  const element = player.parentElement.parentElement.querySelector('.p2p-player-chapters');
  if (!element) return;

  const lines = element
   .innerText
   .split('\n')
   .map(i => i.trim())
   .filter(i => i.length > 0);
  element.innerHTML = '';

  const cues = [];
  for (const [index, line] of lines.entries()) {
   try {
    const timeRegex = /^(\d{2})(?::(\d{2})):?(\d{2})?/;
    const time = line.match(timeRegex);
    if (!time) continue;

    const startTime = parseTime(time);
    if (startTime >= duration) break;

    const text = line.substring(time[0].length).trim();
    let endTime = duration;
    if (index + 1 < lines.length) {
     const nextTime = lines[index + 1].match(timeRegex);
     if (nextTime) {
      endTime = parseTime(nextTime);
      if (endTime > duration) break;
     }
    }
    cues.push({ startTime, endTime, text });

    const timeSpan = document.createElement('span')
    timeSpan.setAttribute('class', 'time')
    timeSpan.innerText = time[0];

    const textSpan = document.createElement('span')
    textSpan.innerText = text;
    textSpan.setAttribute('class', 'text');

    const link = document.createElement('a');
    link.appendChild(timeSpan);
    link.appendChild(textSpan);
    link.setAttribute('href', playerQueryParameters(playerIndex, startTime));
    link.addEventListener('click', event => {
     player.currentTime = startTime;
     if (!player.playing) player.play();
     player.scrollIntoView({ block: 'center', behavior: 'smooth' });
     event.preventDefault();
    });
    element.appendChild(link);
   } catch (err) {
    console.error(err);
   }
  }

  player.textTracks.add({
   type: 'json',
   kind: 'chapters',
   language: '{{ page.lang }}',
   content: { cues },
   default: true,
  });
 };

 const loadMetadata = (player, playerIndex, videoLayout) => {
   loadStoryboard(player, videoLayout);
   loadChapters(player, playerIndex);
 };

 let lastFailureTime = 0;
 let mediaSourceSelectionAttempt = 0;
 let aborted = false;
 const fallback = player => {
  if (player.state.playing) {
   player.setAttribute('autoplay', true);
  }

  const now = Date.now();
  if (now - lastFailureTime < 5000 || (!player.state.waiting && !aborted)) {
   return;
  }
  lastFailureTime = now;

  setTimeout(() => fallback(player), 6000);

  const source = new URL(player.getAttribute('src'));
  const mediaUrls = {{ site.theme_settings.p2p_player.media_urls | jsonify }};

  mediaSourceSelectionAttempt++;
  source.hostname = new URL(mediaUrls[mediaSourceSelectionAttempt % mediaUrls.length]).hostname;

  player.setAttribute('src', source.toString());
  pageLog('new source ' + player.getAttribute('src') + ' attempt=' + mediaSourceSelectionAttempt);
 };

 const initializePlayer = (player, playerIndex, currentTime, autoPlay) => {
  pageLog(`initializePlayer ${playerIndex}`);
  const swarmId = new URL(player.getAttribute('src'));

  const videoLayout = player.querySelector('media-video-layout');
  const poster = player.querySelector('media-poster');

  videoLayout.playbackRates = { min: 0.5, max: 2.5, step: 0.05 };

  if (player.duration > 0) {
   loadMetadata(player, playerIndex, videoLayout);
  } else {
   player.addEventListener('loaded-metadata', event => loadMetadata(player, playerIndex, videoLayout));
  }

  player.addEventListener('play-fail', event => {
   if (event.isOriginTrusted) {
    pageLog('play failed, retrying');
    player.play();
   }
  });

  const controller = new AbortController();
  let initEvents = 0;
  let startedAutoPlay = false;
  for (const i of ['loaded-metadata', 'seeked']) {
   player.addEventListener(i, event => {
    if (controller.signal.aborted) return;
    if (currentTime !== undefined && Math.abs(player.currentTime - currentTime) > 0.01) {
     player.currentTime = currentTime;
     if (autoPlay && !startedAutoPlay && !player.playing) {
      player.play();
      player.scrollIntoView({ block: 'center' });
      startedAutoPlay = true;
     }
     setTimeout(_ => controller.abort(), 500);
    }
    initEvents++;
    if (initEvents >= 2) controller.abort();
   }, { signal: controller.signal });
  }

  for (const i of ['provider-change', 'seeking']) {
   player.addEventListener(i, event => poster.setAttribute('data-visible', true));
  }

  const hidePosterAndPlayButton = () => {
   const style = document.createElement('style');
   style.textContent = `
    .vds-video-layout[data-sm, thumbnails="${videoLayout.getAttribute('thumbnails')}"] {
     .vds-play-button {
      --media-button-size: 50px;
      --media-button-border: none;
      --video-sm-play-button-bg: transparent;
     }
     .vds-play-button:hover {
      --media-button-border: none;
      --video-sm-play-button-bg: transparent;
     }
    }`;
   player.appendChild(style);
   poster.style.visibility = 'hidden';
  };

  player.addEventListener('play', event => hidePosterAndPlayButton());

  player.addEventListener('seeking', event => {
   if (event.originEvent?.type === 'pointerdown') {
    hidePosterAndPlayButton();
   }
  });

  for (const i of ['time-update', 'loaded-metadata', 'seeking', 'seeked']) {
   player.addEventListener(i, event => {
    const currentTime = player.currentTime;
    if (ZapThreads === undefined || currentTime === undefined) return;

    const timeReference = '{{ site.baseurl | prepend: site.url }}{{ page.url }}' + playerQueryParameters(playerIndex, currentTime);
    ZapThreads.setAdditionalTags([['r', timeReference]]);

    const links = [...document.querySelectorAll('.p2p-player-chapters a')].reverse();
    links.forEach(i => i.classList.remove('current'));
    const currentLink = links.find(i => currentTime >= parseInt(i.href.split('/?t=')[1]));
    currentLink?.classList.add('current');
   });
  }

  for (const i of ['abort', 'audio-gain-change', 'audio-track-change', 'audio-tracks-change', 'auto-play', 'auto-play-change', 'auto-play-fail', 'can-load', 'can-load-poster', 'can-play', 'can-play-through', 'controls-change', 'destroy', 'duration-change', 'emptied', 'end', 'ended', 'error', 'fullscreen-change', 'fullscreen-error', 'live-change', 'live-edge-change', 'load-start', 'loaded-data', 'loaded-metadata', 'loop-change', 'media-airplay-request', 'media-audio-gain-change-request', 'media-audio-track-change-request', 'media-clip-end-change-request', 'media-clip-start-change-request', 'media-duration-change-request', 'media-enter-fullscreen-request', 'media-enter-pip-request', 'media-exit-fullscreen-request', 'media-exit-pip-request', 'media-google-cast-request', 'media-live-edge-request', 'media-mute-request', 'media-orientation-lock-request', 'media-orientation-unlock-request', 'media-pause-controls-request', 'media-pause-request', 'media-play-request', 'media-player-connect', 'media-poster-start-loading', 'media-quality-change-request', 'media-rate-change-request', 'media-resume-controls-request', 'media-seek-request', 'media-seeking-request', 'media-start-loading', 'media-text-track-change-request', 'media-type-change', 'media-unmute-request', 'media-user-loop-change-request', 'media-volume-change-request', 'orientation-change', 'pause', 'picture-in-picture-change', 'picture-in-picture-error', 'play', 'play-fail', 'playing', 'plays-inline-change', 'poster-change', 'progress', 'provider-change', 'provider-loader-change', 'provider-setup', 'qualities-change', 'quality-change', 'rate-change', 'remote-playback-change', 'replay', 'seeked', 'seeking', 'stalled', 'started', 'stream-type-change', 'suspend', 'text-track-change', 'text-tracks-change', 'title-change', 'vds-log', 'video-presentation-change', 'view-type-change', 'volume-change']) {
   player.addEventListener(i, event => {
    pageLog(i);
   });
  }

  player.addEventListener('abort', event => {
   aborted = true;
   fallback(player)
  });

  player.addEventListener('can-play', event => {
   aborted = false;
  });

  player.addEventListener('source-change', event => {
   pageLog('source-change' + JSON.stringify(event.detail));
  });

  player.addEventListener('sources-change', event => {
   pageLog('sources-change' + JSON.stringify(event.detail));
  });

  player.addEventListener('error', event => {
   pageLog('error ' + JSON.stringify(event.detail));
   if (event.detail['code'] === 1) {
    fallback(player);
   }
  });

  player.addEventListener("provider-change", event => {
   const provider = event.detail;
   if (provider?.type === 'hls') {
    pageLog('swarmId ' + swarmId);

    provider.library = HlsWithP2P;
    provider.config = {
     p2p: {
      core: {
       // swarmId: swarmId.toString(),
       // isP2PDisabled: false,
       // simultaneousHttpDownloads: 2,
       // simultaneousP2PDownloads: 3,
       // highDemandTimeWindow: 15,
       // httpDownloadTimeWindow: 3e3,
       // p2pDownloadTimeWindow: 6e3,
       // webRtcMaxMessageSize: 64 * 1024 - 1,
       // p2pNotReceivingBytesTimeoutMs: 2e3,
       // p2pInactiveLoaderDestroyTimeoutMs: 30 * 1e3,
       // httpNotReceivingBytesTimeoutMs: 3e3,
       // httpErrorRetries: 3,
       // p2pErrorRetries: 3,
       p2pErrorRetries: Infinity,
       announceTrackers: {{ site.theme_settings.p2p_player.trackers | jsonify }},
       rtcConfig: { iceServers: {{ site.theme_settings.p2p_player.ice_servers | jsonify }}.map(urls => { return { urls }; }) },
       mainStream: {
        swarmId: swarmId.toString(),
       },
       secondaryStream: {
        swarmId: swarmId.toString(),
       },
      },
      onHlsJsCreated: (hls) => {
       hls.p2pEngine.addEventListener('onPeerConnect', params => {
        pageLog('Peer connected:' + params.peerId);
       });
       hls.p2pEngine.addEventListener('onPeerError', params => {
        pageLog('Peer error:' + params.peerId);
       });
       hls.p2pEngine.addEventListener('onPeerClose', params => {
        pageLog('Peer disconnected:' + params.peerId);
       });
       hls.p2pEngine.addEventListener('onChunkDownloaded', (bytesLength, downloadSource, peerId) => {
        if (peerId) {
         pageLog('Peer download:' + bytesLength + ' ' + peerId + ' ' + downloadSource);
        }
       });
       hls.p2pEngine.addEventListener('onChunkUploaded', (bytesLength, peerId) => {
        pageLog('Peer UPdownload:' + bytesLength + ' ' + peerId);
       });
       hls.p2pEngine.addEventListener('onSegmentLoaded', params => {
        if (params.peerId) {
          pageLog('P2P Segment loaded:' + params.bytesLength);
        }
       });
       hls.p2pEngine.addEventListener('onSegmentError', params => {
        pageLog('ERROR loading segment:' + JSON.stringify(params));
        if (params && params['downloadSource'] === 'http' && params['error'] !== undefined && params['error']['type'] === 'bytes-receiving-timeout') {
         pageLog('http timeout failure');
         fallback(player);
        }
       });

       hls.on(Hls.Events.MANIFEST_PARSED, (event, data) => {
        console.log(data);
        pageLog('manifest loaded, found ' + data.levels.length + ' quality level');
       });
       hls.on(Hls.Events.BUFFER_CREATED, (event, data) => {
        pageLog('codec: ' + data.tracks.audiovideo.codec);
       });
       // TODO: connectedPeerCount

       pageLog(codecSupported(`video/mp4;codecs="avc1.64002a,mp4a.40.2"`) + ' ' + codecSupported(`video/webm;codecs="av01.0.09M.08.0.110.01.01.01.0,opus"`));
      },
     },
    };
   }
  });
 };

 const currentLocation = new URL(window.location.href);
 const currentTime = [...currentLocation.searchParams]
  .filter(([key, _]) => key === 't')
  .map(([_, value]) => parseFloat(value));
 currentLocation.searchParams.delete('t');
 history.replaceState(undefined, '', currentLocation.pathname + currentLocation.search);
 if (Hls?.isSupported()) {
  pageLog('hls is supported');
  let maybeAutoPlay = true;
  document
   .querySelectorAll('media-player')
   .forEach((player, playerIndex) => {
    const time = currentTime[playerIndex];
    const undefinedTime = [undefined, NaN].includes(time);
    const autoPlay = !undefinedTime && maybeAutoPlay;
    initializePlayer(player, playerIndex, undefinedTime ? undefined : time, autoPlay);
    if (autoPlay) maybeAutoPlay = false;
   });
 } else {
  console.error('hls is unsupported');
 }
});
</script>


{% if site.theme_settings.google_analytics %}
<script src="https://www.googletagmanager.com/gtag/js?id={{ site.theme_settings.google_analytics }}" async></script>
<script>
window.dataLayer = window.dataLayer || [];
function gtag(){dataLayer.push(arguments);}
gtag('js', new Date());
gtag('config', '{{ site.theme_settings.google_analytics }}');
</script>
{% endif %}

{% if site.theme_settings.zapthreads %}
<script type="text/javascript" src="/assets/js/vendor/zapthreads.iife.js"></script>
{% endif %}

<meta name="twitter:site" content="@{{ site.theme_settings.twitter }}">

{% if page.summary %}
<meta name="twitter:description" content="{{ page.summary }}">
{% else %}
<meta name="twitter:description" content="{% if page.lang == 'en' %}{{ site.description | xml_escape }}{% else %}{{ page.str.description | xml_escape }}{% endif %}">
{% endif %}

{% if page.thumbnail %}
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="{{ site.url }}/{{ page.thumbnail }}">
{% else %}
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="{{ site.title_image }}">
{% endif %}

{% if page.lang != 'en' and page.layout == 'home' %}
<title>{{ site.title }} | {{ page.str.description | xml_escape }}</title>
{% seo title=false %}
{% else %}
{% seo %}
{% endif %}

<link rel="alternate" type="application/atom+xml" title="{{ site.title }}" href="{{ site.url }}/{% if page.lang != 'en' %}{{ page.lang }}/{% endif %}{{ site.baseurl }}feed.xml"/>

<script type="module" src="/assets/js/main.min.js" defer></script>
{% include lazy_load_css.html href="/assets/css/main.css" %}
</head>
